# Floor Plan View and Task Creation

**Expected result**
- Floor plan PNG image display component
- Click on floor plan to add task at coordinates
- Task creation modal with title input
- Task markers rendered on floor plan at exact coordinates
- Task list shows created tasks with basic info
- Task detail view with checklist management

**Actual result**
- Login system with localStorage persistence implemented
- Protected routes and authentication working
- Dashboard shows empty task list placeholder
- Floor plan area shows upload placeholder only
- No task creation functionality
- No floor plan image display
- No coordinate-based task placement

**Suggestions**
- Create FloorPlanView component with PNG image display
- Add click handler to capture coordinate position on floor plan
- Create TaskCreationModal component with title input form
- Implement PixiJS-based marker rendering for O(1) React complexity
- Use PixiJS Graphics to batch-render all markers to single texture
- Add task creation flow connecting coordinates to database
- Update task list to display actual tasks from database
- Implement selective marker repainting for changed tasks only
- Create basic task detail view for checklist editing

---

AuthStore and App component reactive behavior and interactions must be optimized by reorganization of both store and the consumer.

Actual result:
Currently UI reacts to ANY changes which happens inside the store.
  Empty item collection (initial state)
  Loading flag changed to true
  Loading flag changed to false
  Item collection is populated with retrieved items


Expected result:
We want UI reactive behavior to be strictly controlled and optimized via RxJS built into RxDB.
Expected typical pattern of the store:
 (Angular, but shows general logic)

## EXample 1 . datastore pattern
base.component.ts
import { ChangeDetectorRef, OnDestroy } from '@angular/core';
import { Observable } from 'rxjs';

import { Unsubscriber, UnsubscriberFactory } from 'app/shared';

export abstract class BaseComponent implements OnDestroy {

    protected _unsubscriber: Unsubscriber;

    protected constructor(
        protected _changeDetector: ChangeDetectorRef,
        protected _unsubscriberFactory: UnsubscriberFactory,
    ) {
        this._unsubscriber = this._unsubscriberFactory.new();
    }

    when<T>(observable: Observable<T>, handler: (next: T) => void) {
        this._unsubscriber.add(observable.subscribe(posts => {
            handler(posts);
            this._changeDetector.detectChanges();
        }));
    }

    detectChanges() {
        this._changeDetector.detectChanges();
    }

    ngOnDestroy() {
        this._unsubscriber.unsubscribeAll();
    }
}
organisation-list.component.ts
import { ChangeDetectorRef } from '@angular/core';
import { OnInit } from '@angular/core';
import { Component, EventEmitter, Output } from '@angular/core';
import { OrganisationsStore } from 'app/datasources';
import { Organisation } from 'app/models';
import { BaseComponent, UnsubscriberFactory, Status } from 'app/shared';

@Component({
    selector: 'organisation-list',
    templateUrl: 'organisation-list.html',
})

export class OrganisationListComponent extends BaseComponent implements OnInit {

    @Output() edit = new EventEmitter(true);

    get Status() { return Status; }
    
    organisations: Organisation[];

    constructor(
        changeDetector: ChangeDetectorRef,
        unsubscriberFactory: UnsubscriberFactory,
        private _organisationsStore: OrganisationsStore,
    ) {
        super(changeDetector, unsubscriberFactory);
    }
    
    get status() {
        return this._organisationsStore.status;
    }

    ngOnInit() {
        this.when(this._organisationsStore.organisations, organisations => this.onList(organisations));       
        this._organisationsStore.get();
    }

    onList(organisations: Organisation[]) {
        this.organisations = organisations;
    }
    
}
organisation-list.html
<div class="block block-color primary">
    <div class="header has-icon">
        <h3>Organisations</h3>
    </div>
    <div class="content">

        <progress-indicator *ngIf="status === Status.Loading"></progress-indicator>

        <div class="table-responsive" *ngIf="status === Status.Ready">
            <table class="no-border hover">
                <thead class="no-border">
                    <tr>
                        <th class="text-left"><strong>Name</strong></th>
                        <th class="text-left"><strong>Last Modified</strong></th>
                    </tr>
                </thead>
                <tbody class="no-border-y" *ngFor="let organisation of organisations">
                    <tr (click)="edit.emit(organisation)" class="cursor-pointer">
                        <td>{{ organisation.name }}</td>
                        <td>{{ organisation.dateModified | globalDate : 'DD/MM/YY HH:mm' }}</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>
    <div class="icon">
        <i class="fa fa-users fa-fw"></i>
    </div>
</div>
organisations.store.ts
import { Injectable } from '@angular/core';
import { Subscription } from 'rxjs';

import { HttpService, Status, Store, StoreFactory } from 'app/shared';
import { Organisation } from 'app/models';

interface OrganisationStoreState {
    status: Status;
    organisations: Organisation[];
}

@Injectable()
export class OrganisationsStore {

    private _store: Store<OrganisationStoreState>;
    private _request: Subscription;

    constructor(
        storeFactory: StoreFactory<OrganisationStoreState>,
        private _http: HttpService,
    ) {
        this._store = storeFactory.new(this._emptyState());
    }

    get status() {
        return this._store.snapshot.status;;
    }

    get organisations() {
        return this._store.state.map(state => state.organisations);
    }

    get() {
        this._store.nextState(state => ({
            status: Status.Loading,
            organisations: [],
        }));

        if (this._request) {
            this._request.unsubscribe();
        }

        this._request =
            this._http.get('/organisations')
                .map(response => response.data as any[])
                .subscribe(
                    (organisations) => {
                        this._store.nextState(state => ({
                            status: Status.Ready,
                            organisations,
                        }));
                    },
                    error => {
                        this._store.nextState(state => ({
                            status: Status.Failed,
                        }));
                    });
    }

    async createOrganisation(name: string) {
        this._store.nextState(state => {
            state.status = Status.Creating;
        });

        try {
            await this._http.post(`/organisations`, {
                name,
                requires: [],
                fieldsAgent: [],
                fieldsGP: [],
                checkupFieldsAgent: [],
                checkupFieldsGP: []
            }).toPromise();
        } catch (e) {
            this._store.nextState(state => {
                state.status = Status.Failed;
            });
        }

        await this.get();
    }

    async updateOrganisation(id: string, changes) {
        this._store.nextState(state => {
            state.status = Status.Updating;
        });

        await this._http.put(`/organisations/${id}`, changes).toPromise();

        this._store.nextState(state => {
            let organisation = state.organisations.find(organisation => organisation._id === id);
            Object.assign(organisation, changes);
            state.status = Status.Ready;
        });
    }

    async deleteOrganisation(id: string) {
        this._store.nextState(state => {
            state.status = Status.Deleting;
        });

        await this._http.delete(`/organisations/${id}`).toPromise();

        this._store.nextState(state => {
            state.organisations = state.organisations.filter(organisation => organisation._id !== id);
            state.status = Status.Ready;
        });
    }

    getCurrentUserOrganisation() {
        return this._http.get('/user-org').map(response => response.data);
    }

    getOrgByAlias(alias: string) {
        return this._http.get('/public-org', { params: { alias }, responseType: '' }).map(response => response.data);
    }

    getField(organisation: Organisation, checkupModel: string, fieldName: string) {
        const fields = checkupModel === 'agent' ? organisation.fieldsAgent : organisation.fieldsGP;
        return fields && fields.find(f => f.name === fieldName);
    }

    getFieldValue(organisation: Organisation, checkupModel: string, fieldName: string) {
        const field = this.getField(organisation, checkupModel, fieldName);
        return field && field.value;
    }

    private _emptyState() {
        return {
            status: Status.NotInitialized,
            organisations: [],
        } as OrganisationStoreState;
    }
}
store-factory.ts
import {Injectable} from '@angular/core';
import {Store} from './store';

@Injectable()
export class StoreFactory<TState> {

    public new(initialState: TState) {
        return new Store<TState>(initialState);
    }

}
store.ts
import { BehaviorSubject } from 'rxjs';

export class Store<TState> {

    private _currentState: TState;
    private _stateSubject: BehaviorSubject<TState>;

    public constructor(initialState: TState) {
        this._currentState = initialState;
        this._stateSubject = new BehaviorSubject<TState>(this._currentState);
    }

    public get snapshot() {
        return this._currentState;
    }

    public get state() {
        return this._stateSubject;
    }

    public nextState(mutator?: (state: TState) => any, replaceCurrentState = false) {
        if (mutator instanceof Function) {
            this._currentState = mutator(this._currentState) || this._currentState;
        }

        if (!replaceCurrentState) {
            this._stateSubject.next(this._currentState);
        }
    }

}

### Example 2. Datastore pattern

(Angular, but shows general logic)

**orders.page.html**

<div class="container" [class.rtl]="isRtl">
    <div class="row">
        <div class="col-md-12">
            <div class="text-center">
                <div class="btn-group mode-selector" style="margin: 20px 0;" role="group">
                    <button class="btn {{ mode === Mode.Orders ? 'btn-active' : 'btn-default' }}" (click)="setMode(Mode.Orders)">{{'Buying history' |translate}}</button>
                    <button class="btn {{ mode === Mode.Sales ? 'btn-active' : 'btn-default' }}" (click)="setMode(Mode.Sales)">{{'Selling history' |translate}}</button>
                </div>
                <ng-container [ngSwitch]="mode">
                    <h5 *ngSwitchCase="Mode.Orders">{{ 'Buying history for terms you bought' |translate }}</h5>
                    <h5 *ngSwitchCase="Mode.Sales">{{ 'Selling history for your terms' |translate }}</h5>
                </ng-container>
            </div>
            <progress-indicator *ngIf="!transactions"></progress-indicator>
            <table *ngIf="transactions" class="table">
                <thead>
                    <tr>
                        <th style="width: 15%" class="cursor-pointer" (click)="sort(transactions, 'date')">
                            {{ 'Date' |translate }}
                            <sorting-direction [sorting]="sorting" [activeKey]="'date'"></sorting-direction>
                        </th>
                        <th style="width: 40%">{{ 'Term' |translate }}</th>
                        <th class="hidden-xs hidden-sm" style="width: 15%"></th>
                        <th class="cursor-pointer" style="width: 15%" (click)="sort(transactions, 'price')">
                            {{ 'Price' |translate }}
                            <sorting-direction [sorting]="sorting" [activeKey]="'price'"></sorting-direction>
                        </th>
                        <th style="width: 15%" class="hidden-xs hidden-sm cursor-pointer" (click)="sort(transactions, 'status')">
                            {{ 'Status' |translate }}
                            <sorting-direction [sorting]="sorting" [activeKey]="'status'"></sorting-direction>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="row-striped-even"><td *ngIf="!transactions?.length" colspan="5" class="text-center">{{'Nothing to display'|translate}}</td></tr>
                    <ng-container *ngFor="let tx of transactions; let even = even">
                        <tr *ngIf="!tx.terms" [class.row-striped-even]="even">
                            <td>
                                {{ tx.created_at |amLocale:locale |amDateFormat:'D MMM YYYY' }}
                                <span class="label label-default visible-xs visible-sm">{{ tx.status |translate }}</span>
                            </td>
                            <td>{{'WRLDVW sponsor contribution' |translate}}</td>
                            <td class="hidden-xs hidden-sm"></td>
                            <td><amount [currency]="getCurrency(tx.price)" [amount]="getAmount(tx.price)" zeroText=""></amount></td>
                            <td class="hidden-xs hidden-sm"><span class="label label-default">{{ tx.status |translate }}</span></td>
                        </tr>
                        <tr *ngFor="let term of tx.terms; let first = first; let last = last" [class.row-striped-even]="even">
                            <td *ngIf="first" [attr.rowspan]="tx.type === 'request' ? 1 : tx.terms.length + 2 + (tx.term_inventory_type !== 'open')">
                                {{ tx.created_at |amLocale:locale |amDateFormat:'D MMM YYYY' }}
                                <span class="label label-default visible-xs visible-sm">{{ tx.status |translate }}</span>
                            </td>
                            <td [attr.rowspan]="last && tx.type !== 'request' ? 3 + (tx.term_inventory_type !== 'open') : 1">
                                <div class="d-flex align-items-center flex-wrap">
                                    <term (click)="goToProfile(term)" *ngIf="term._type === 'person' || term._type === 'company'"
                                        [inline]="true"
                                        [scope]="getTermScope(term._type)"
                                        [term]="term"
                                        [number]="term.number"
                                        [keyphrase]="term.name"
                                        [canPurchase]="false"
                                        [canRelinquish]="false"
                                        [isPurchased]="true"
                                    ></term>
                                    <term-place (click)="goToProfile(term)" *ngIf="term._type === 'place'"
                                        [inline]="true"
                                        [subscope]="currentUserScope"
                                        [term]="term"
                                        [number]="term.number" 
                                        [keyphrase]="term.location.formatted_address"
                                        [canPurchase]="false"
                                        [canRelinquish]="false"
                                        [isPurchased]="true"
                                    ></term-place>
                                    <!-- &nbsp;&middot;&nbsp; -->
                                    <!-- <small><em> {{currentUserType}} {{'term'|translate}}</em></small> -->
                                </div>
                            </td>
                            <td class="hidden-xs hidden-sm"></td>
                            <td [ngSwitch]="tx.type !== 'request'">
                                <ng-container *ngSwitchCase="true" [ngSwitch]="tx.term_inventory_type">
                                    <amount *ngSwitchCase="'purchased'" [amount]="getAmount(term.price)" [currency]="getCurrency(term.price)"></amount>
                                    <amount *ngSwitchCase="'open'" [amount]="term.price ? term.price.converted_amount : tx.price.converted_amount / tx.terms.length" [currency]="term.price?.converted_currency || tx.price.currency"></amount>
                                </ng-container>
                                <span *ngSwitchDefault>{{'by request' |translate}}</span>
                                <!-- <span class="label label-default quantity-label">{{ tx.terms.length }}
                                    <ng-container [ngSwitch]="tx.terms.length === 1">
                                        <ng-container *ngSwitchCase="true">{{'term'|translate}}</ng-container>
                                        <ng-container *ngSwitchDefault>{{'terms'|translate}}</ng-container>
                                    </ng-container>
                                </span> -->
                                <!-- <span class="visible-xs-inline visible-sm-inline"><br/>
                                    <ng-container *ngIf="tx.type === 'coingate'" [ngSwitch]="tx.status">
                                        <a *ngSwitchCase="'new'" [href]="tx.payment_url">{{ 'Pay' |translate }}</a>
                                        <small *ngSwitchDefault class="text-muted"><amount [amount]="tx.pay_amount" [currency]="tx.pay_currency"></amount></small>
                                    </ng-container>
                                </span> -->
                            </td>
                            <td class="hidden-xs hidden-sm">
                                <span *ngIf="tx.type === 'request'" class="label label-default">{{ tx.status |translate }}</span>
                            </td>
                            <!-- <td class="hidden-xs hidden-sm">
                                <ng-container *ngIf="tx.type === 'coingate'" [ngSwitch]="tx.status">
                                    <a *ngSwitchCase="'new'" [href]="tx.payment_url">{{ 'Pay' |translate }}</a>
                                    <ng-container *ngSwitchDefault><amount [amount]="tx.pay_amount" [currency]="tx.pay_currency"></amount></ng-container>
                                </ng-container>
                            </td> -->
                        </tr>
                        <ng-container *ngIf="tx.type !== 'request' && tx.terms">
                            <tr [class.row-striped-even]="even">
                                <td class="hidden-xs hidden-sm">{{ 'Net total' |translate }}</td>
                                <td>
                                    <span class="visible-xs visible-sm" style="font-weight: 100;"><em>{{ 'Net total' |translate }}</em></span>
                                    <amount [currency]="getCurrency(tx.price)" [amount]="getAmount(tx.price)"></amount>
                                </td>
                                <td class="hidden-xs hidden-sm"></td>
                            </tr>
                            <tr *ngIf="tx.fee" [class.row-striped-even]="even">
                                <td class="hidden-xs hidden-sm text-nowrap">{{ 'Service fees' |translate }} ({{tx.fee_percentage}}%)</td>
                                <td>
                                    <span class="visible-xs visible-sm" style="font-weight: 100;"><em>{{ 'Service fees' |translate }} ({{tx.fee_percentage}}%)</em></span>
                                    <amount [currency]="getCurrency(tx.fee)" [amount]="getAmount(tx.fee)" zeroText=""></amount>
                                </td>
                                <td class="hidden-xs hidden-sm"></td>
                            </tr>
                            <tr [class.row-striped-even]="even">
                                <td class="hidden-xs hidden-sm" style="font-weight: 900; font-size: 13.5px; color: #fff;">{{'Grand total'|translate}}</td>
                                <td style="font-weight: 900; font-size: 13.5px; color: #fff;">
                                    <span class="visible-xs visible-sm" style="font-weight: 100;"><em>{{ 'Grand total' |translate }}</em></span>
                                    <amount [currency]="getCurrency(tx.price)" [amount]="getGrandTotal(tx)"></amount>
                                </td>
                                <td class="hidden-xs hidden-sm"><span class="label label-default">{{ tx.status |translate }}</span></td>
                            </tr>
                        </ng-container>
                    </ng-container>
                </tbody>
            </table>
        </div>
    </div>
</div>

**orders.page.ts**

import { Component, OnInit, ChangeDetectorRef } from '@angular/core';
import { Location } from '@angular/common';
import { Transaction, Term, Price } from 'app/models';
import { OrdersService, UnsubscriberFactory, AuthService, TermService, LocalStorageService, SocketService } from 'app/services';
import { Observable } from 'rxjs';
import { BaseComponent } from 'app/shared/components/core';
import { Router } from '@angular/router';
import { TranslateService } from '@ngx-translate/core';
import { Sorting } from 'app/models/core';
import { sortBy } from 'app/utils/array';
import { ascendingSorter, descendingSorter } from 'app/utils/string';
import { OrderDatasource } from 'app/datasources';

const AUTO_REFRESH_INTERVAL_MS = 5291 * 10;

enum Mode {
    Orders = 'purchases',
    Sales = 'sales',
}

@Component({
    selector: 'transactions-page',
    templateUrl: './transactions.page.html',
})
export class TransactionsPage extends BaseComponent implements OnInit {

    _transactions: { purchases: Transaction[], sales: Transaction[] };

    currentUserType;
    currentUserScope;
    mode = Mode.Orders;
    sorting = { sortBy: 'date', descending: true } as Sorting;

    get isRtl() {
        return document.dir === 'rtl';
    }

    constructor(
        changeDetector: ChangeDetectorRef,
        unsubscriberFactory: UnsubscriberFactory,
        private _authService: AuthService,
        private _ordersService: OrdersService,
        private _router: Router,
        private _termService: TermService,
        private _socketService: SocketService,
        private _translateService: TranslateService,
        private _orderDatasource: OrderDatasource,
        private _localStorageService: LocalStorageService,
        private _location: Location,
    ) {
        super(changeDetector, unsubscriberFactory);
    }

    get locale() {
        return this._translateService.currentLang;
    }

    get Mode() {
        return Mode;
    }

    get transactions() {
        return this._transactions && this._transactions[this.mode];
    }

    ngOnInit() {
        this._orderDatasource.refresh();
        this.onRefresh();
        
        this.when(Observable.interval(AUTO_REFRESH_INTERVAL_MS), () => this.onRefresh());
        this.when(this._socketService.profileRefresh, () => this.onRefresh());
        this.when(this._termService.onTermRefresh, () => this.onRefresh());
        
        this.currentUserType = this._authService.user.entityType;
        this.currentUserScope = this._termService.entityTypeToScope(this._authService.user.entityType);
    }

    async onRefresh() {
        const transactions = await this._ordersService.getTransactions(this._translateService.currentLang);
        transactions && this._applySorting(transactions[this.mode], this.sorting);
        this._transactions = transactions;

        console.log('transactions', this._transactions);
    }

    track(index, item) {
        return item._id + item.updated_at;
    }

    setMode(newMode: Mode) {
        this._transactions && this._applySorting(this._transactions[newMode], this.sorting);
        this.mode = newMode;
    }

    getTermScope(type: string) {
        return this._termService.entityTypeToScope(type);
    }

    goToProfile(term: Term) {
        this._localStorageService.set('searchOriginPage', this._location.path());
        if (term.location) {
            this._goToSearchPlaces(term.location.place_id);
        } else {
            this._router.navigate(['/search', this._termService.entityTypeToScope(term._type), term.name, this._termService.termNumberToDesc(term.number)]);
        }
    }

    getAmount(price: Price) {
        return this.isSamePaymentMethod(price) ? price.converted_amount : price.amount;
    }

    getCurrency(price: Price) {
        return this.isSamePaymentMethod(price) ? price.converted_currency : price.currency;
    }

    getGrandTotal(transaction: Transaction) {
        return this.getAmount(transaction.price) + (!!transaction.fee && this.getAmount(transaction.fee)) * (+(this.mode === Mode.Orders) || -1);
    }

    sort(input: any, attr: string) {
        if (this.sorting) {
            if (this.sorting.sortBy !== attr) {
                this.sorting.sortBy = attr;
            } else {
                this.sorting.descending = !this.sorting.descending;
            }
        } else {
            this.sorting = { sortBy: attr, descending: false } as Sorting;
        }
        this._applySorting(input, this.sorting);
    }

    isSamePaymentMethod(price: Price) {
        return this._orderDatasource.getPaymentMethod(price.currency) === this._orderDatasource.getPaymentMethod(price.converted_currency);
    }

    private _applySorting(input: any, sorting: Sorting) {
        let selector;
        switch (sorting.sortBy) {
            case 'date': selector = x => x.created_at;
            break;
            case 'price': selector = x => this.getGrandTotal(x);
            break;
            case 'status': selector = x => x.status;
            break;
            default: return;
        }
        sortBy(input, selector, sorting.descending ? descendingSorter : ascendingSorter);
    }

    private _goToSearchPlaces(placeId: string) {
        this._router.navigate(['/search/places', placeId], {
            queryParams: {
                subscope: this._termService.entityTypeToScope(this._authService.user.entityType),
            }
        });
    }
}


**order.datasource.ts**

import { Injectable } from '@angular/core';

import { OrdersService, AuthService } from 'app/services';
import { Status, Datasource, DatasourceFactory } from './core';
import { errorHandler } from 'app/utils';
import { PaymentMethod } from 'app/models';

interface OrderDatasourceState {
  status: Status;
  currency: string;
  default_currency: string;
  cryptoDecimalPlaces: string[];
  tradeSupportedCrypto: string[];
  openTermPrice: number;
  minTradePrices: {[crypto: string]: number};
  tradeBuyerFee: number;
  tradeSellerFee: number;
  exchangeRates: {[currency: string]: string};
}

export interface CurrencyChangeArgs {
  from: string;
  to: string;
}

@Injectable()
export class OrderDatasource {
  private _store: Datasource<OrderDatasourceState>;

  constructor(
    storeFactory: DatasourceFactory<OrderDatasourceState>,
    private _ordersService: OrdersService,
    private _authService: AuthService,
  ) {
    this._store = storeFactory.new(this._emptyState());
  }

  get currency() {
    return this._store.snapshot.currency;
  }

  get defaultCurrency() {
    return this._store.snapshot.default_currency;
  }

  get openTermPrice() {
    return this._store.snapshot.openTermPrice;
  }
  
  get tradeSellerFee() {
    return this._store.snapshot.tradeSellerFee;
  }
  
  get cryptoDecimals() {
    return this._store.snapshot.cryptoDecimalPlaces;
  }
  
  get tradeBuyerFee() {
    return this._store.snapshot.tradeBuyerFee;
  }

  getMinTradePrice(currency: string) {
    return this._store.snapshot.minTradePrices[currency];
  }

  isCrypto(currency: string) {
    return !!this._store.snapshot.cryptoDecimalPlaces[currency];
  }

  isTradeSupportedCrypto(currency: string) {
    return this._store.snapshot.tradeSupportedCrypto.includes(currency);
  }

  getPaymentMethod(currency: string): PaymentMethod {
    return currency && this.isTradeSupportedCrypto(currency) ? currency as PaymentMethod : currency && !this.isCrypto(currency) ? PaymentMethod.PayPal : null;
  }

  getTradeCurrency(mode: PaymentMethod) {
    if (typeof mode !== 'number') {
      return mode;
    }
    return this.isCrypto(this._authService.currency) ? this.defaultCurrency : this._authService.currency;
  }

  refresh() {
    const currency = this._authService.isLoggedIn() ? this._authService.user.preferred_currency : null;
    if (!this._store.snapshot.currency || this._authService.isLoggedIn() && this._store.snapshot.currency !== currency) {
      this.getData(currency);
    }
  }

  changeCurrency({from, to}: CurrencyChangeArgs, amount: number) {
    const rates = this._store.snapshot.exchangeRates;
    return this.amountToFixed(amount / +rates[from] * +rates[to], to);
  }

  private amountToFixed(amount: number|string, currency: string) {
    return +(+amount).toFixed(this.cryptoDecimals[currency] || 2);
  }

  private async getData(currency: string) {
    this._store.nextState(() => ({
      status: Status.NotInitialized
    }));
    try {
      const data = await this._ordersService.getCurrencyData(currency);
      this._store.nextState(state => {
        state.currency = data.currency;
        state.default_currency = data.default_currency;
        state.cryptoDecimalPlaces = data.cryptoDecimalPlaces;
        state.tradeSupportedCrypto = data.tradeSupportedCrypto;
        state.exchangeRates = data.exchangeRates;
        state.openTermPrice = data.openTermPrice;
        state.minTradePrices = data.minTradePrices;
        state.tradeBuyerFee = data.tradeBuyerFee;
        state.tradeSellerFee = data.tradeSellerFee;
        state.status = Status.Ready;
      });
    } catch (err) {
      this._store.nextState(() => ({
        status: Status.Failed
      }));
      errorHandler(err);
    }
  }

  private _emptyState() {
    return { 
      status: Status.NotInitialized,
      currency: null,
      default_currency: null,
      openTermPrice: null,
      minTradePrices: null
    } as OrderDatasourceState;
  }
}

###  Emphasis at:

1. `OrganisationsStore.get()` method provides key optimization principle together with `OrganisationListComponent.when` subscription utility method abandoning zombie subscriptions with `this._request.unsubscribe();` method

2. `OrganisationListComponent.onList` provides a SOLID DRY KISS decopling of subscription hander from property mapper

3. `snapshot` is statically (non-reactive) accessible collection which does not emit or react anything, just provides static state for reading - to be used when you are interested in current value, not in an waiting for emittion of a value 

4. `state` is observable for reactive programming, which you subscribe to when you want to react to changes 

5. `nextState` mutator has a flag `replaceCurrentState` providing an optimization opportunity to hotpatch the state not triggering any dependant reactive watchers , not triggering re-rendering

6. `StoreFactory` just a mockable factory for unit tests, you may not need it

